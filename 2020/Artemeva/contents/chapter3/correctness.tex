\subsection{Корректность алгоритма аннотирования}

Алгоритм аннотирования, представленный в работе, способен аннотировать только нормализованные программы на \miniKanren{}.
Однако, любую программу на \miniKanren{} можно привести в нормальную форму описанными выше методами~\ref{lab:normProof}.
Доказав корректность аннотирования нормализованных программ, мы докажем и корректность ненормализованных.

Алгоритм представляет собой адаптацию алгоритма анализа времени связывания для \miniKanren{}.
Для доказательства корректности необходимо показать его терминируемость и согласованность, что и сделано в последующих разделах.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Терминируемость}

\begin{theorem}
Предложенный в разделе~\ref{lab:coreAnn} алгоритм аннотирования нормализованных программ терминируется
\end{theorem}

\begin{proof}
Алгоритм терминируется, так как повторное аннотирование отношений не производится.
Это, в свою очередь, означает, что будет достигнута неподвижная точка и алгоритм завершит свою работу.
Проверим, что каждая из частей алгоритма не производит повторного аннотирования.

\textit{Унификация}.
Аннотирование происходит только в случае существования $Undef$-аннотаций.

\textit{Вызов отношения}.
Имеющиеся в стеке вызовов отношения не аннотируются снова, а в каждом отношении используется конечное количество уникальных переменных.

\textit{Конъюнкция / Дизъюнкт}.
Так как конъюнкт --- либо унификация, либо вызов отношения, то ни один конъюнкт не будет проаннотирован повторно.
Конъюнктов в дизъюнкте конечное количество, значит, неподвижная точка будет достигнута.

\textit{Объявление новых переменных}.
Только на верхнем уровне; аннотирование такой цели равнозначно аннотированию цели внутри $fresh$-цели.

\textit{Дизъюнкция}.
Аннотирование происходит независимо для каждого дизъюнкта.

Из представленых выше рассуждений можно сделать вывод, что каждому отношению можно сопоставить конечное количество уникальных аннотаций и терминируемость этой части алгоритма доказана.
\end{proof}

\begin{theorem} Предложенная в разделе~\ref{lab:disjPerm} модификация алгоритма аннотирования нормализованных программ для разрешения проблемы нескольких вызовов в одном дизъюнкте терминируется.
\end{theorem}

\begin{proof}
Существование нескольких вызовов в одном дизъюнкте приводит к необходимости применять алгоритм аннотирования ко всем возможным версиям дизъюнкта, каждая из которых отличается очередной перестановкой вызовов.
Терминируемость в этом случае следует из двух фактов:
\begin{itemize}
    \item количество перестановок вызовов конечно и, значит, конечно количество версий дизъюнкта;
    \item алгоритм аннотирования нормализованных программ терминируется.
\end{itemize}
\end{proof}

\begin{theorem} 
Предложенная в разделе~\ref{lab:gen} модификация алгоритма аннотирования нормализованных программ для разрешения проблемы зависимости $fresh$-переменных только друг от друга терминируется.
\end{theorem}

\begin{proof}
Добавление генерации не влияет на терминируемость несмотря на итеративность процесса.
Терминируемость следует из двух фактов.
\begin{itemize}
    \item Количество переменных, оставшихся в случае неуспешного аннотирования помеченными $Undef$, конечно для всего стека вызовов, так как конечно количество переменных в любом отношении, а, значит, и в стеке вызовов; на каждой итерации генерации происходит добавление хотя бы одной генерации хотя бы в одно определение со стека вызовов.
    \item Aлгоритм аннотирования нормализованных программ, запускаемый повторно после генерации, терминируется.
\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Согласованность}

В анализе времени связывания под согласованностью понимается \emph{зависимость статических данных только от статических}: статические данные не могут определяться динамическими.

\begin{theorem} 
Предложенный в разделе~\ref{lab:coreAnn} алгоритм аннотирования нормализованных программ с модификациями для разрешения проблемы нескольких вызовов в одном дизъюнкте~\ref{lab:disjPerm} и проблемы зависимости $fresh$-переменных только друг от друга~\ref{lab:gen} является согласованным.
\end{theorem}

\begin{proof}
Вычисление дизъюнктов в \miniKanren{} происходит независимо, значит, и аннотировать их можно независимо.
Как следствие, для аннотации тела отношения необходимо проаннотировать входящие в него дизъюнкты.
Показав корректность аннотирования одного дизъюнкта, покажем корректность аннотирования всего тела.

Каждый дизъюнкт --- это конъюнкция вызовов и унификаций.
Вычисление конъюнктов в \miniKanren{} происходит одновременно: значение полученное в одном конъюнкте, мгновенно становится известно в другом.
Для аннотирования это означает, что, если стала известна аннотация целевой переменной в одном конъюнкте, она мгновенно становится известна во всех конъюнктах, в которые эта переменная входит.
Именно так и происходит в алгоритме: дизъюнкты аннотируются независимо, а аннотация переменной, ставшая известной в одном конъюнкте, распространяется на все вхождения этой переменной в другие конъюнкты.

Введём понятие зависимости одной переменной от другой в рамках предложенного алгоритма.
Понятие отношения подразумевает ``равноправие'' переменных, участвующих в нём.
Однако, при выборе конкретного направления вычисления значения переменных множества $X$ становятся известны раньше значений переменных множества $Y$.
В этом случае будем говорить, что переменные Y \emph{зависят} от переменных X.
Проиллюстрируем понятие зависимости переменных друг от друга на примерах.

Пример: зависимость для унификаций.
Пусть есть два конъюнкта: $x \equiv y$ и $y \equiv 7$.
Во втором конъюнкте $7$ --- константа, поэтому мы можем проунифицировать $y$ и сказать, что $y = 7$.
В этот же момент мы узнаем в первом конъюнкте, что $y$ стала известна, и можем превратить унификацию в равенство $x = y$, обозначающее зависимость $x$ от $y$.

Пример: зависимость для вызовов отношений.
Пусть есть вызов отношения $append^o~x~y~z$, где мы уже знаем из других конъюнктов значение $z$.
В этом случае алгоритм посчитает, что этот вызов $append^o$ происходит направлении, при котором переменные $x$ и $y$ являются выходными.
В этом случае можно говорить о зависимости $x$ и $y$ от $z$: $(x,~y)~=~append^o~z$ (в случае недетерминированной семантики $apppend^o$ корректнее говорить о $[(x,~y)]~=~append^o~z$).

Введём инвариант, отражающий идею согласованности.
Доказав его выполнение на любом шаге алгоритма, докажем его корректность.

\emph{Инвариант:
\begin{itemize}
    \item либо переменная не проаннотирована (имеет аннотацию $Undef$);
    \item либо переменная проаннотирована числом; тогда существует хотя бы один конъюнкт, в котором все переменные, от которых она зависит, проаннотированы строго меньшими числами.
\end{itemize}
}

Рассмотрим алгоритм, чтобы убедиться в выполнении инварианта.
В начальный момент времени аннотацию $0$ имеют только входные переменные.
Остальные переменные проаннотированы $Undef$.

Конъюнкты отсортированы: вызовы следуют за унификациями.
К каждой унификации применяется алгоритм аннотирования унификаций, в точности выполняющий инвариант.
$Undef$-аннотация целевой переменной заменяется всегда на строго большее значение, чем значение аннотации любой переменной, от которой целевая переменная зависит.
После аннотирования каждого конъюнкта информация об аннотациях его переменных распространяется на все оставшиеся конъюнкты.
Следующий для аннотирования конъюнкт обладает релевантными аннотациями.

К моменту начала аннотирования вызовов отношения можем быть уверены, что в текущем вызове известны все аннотации переменных, которые можно было получить из унификаций.
Все другие --- только из последующих вызовов отношений.
Тем самым, мы знаем направление первого вызова в текущей перестановке вызовов конкретного дизъюнкта.
При наличии нескольких вызовов их порядок влияет на аннотирование.
Наилучший порядок, позволяющий получить проаннотированное отношение, можно найти только опытным путём --- перебрав все перестановки вызовов.
Поэтому, без ограничения общности можно считать, что первый вызов выбран верно.
Если аннотирование при этом закончится неудачей, запустится аннотирование того же дизъюнкта с другим порядком вызовов.
Важно заметить, что, в случае неуспеха аннотирования стек вызовов будет содержать переменные с $Undef$ аннотациями --- это является частью инварианта.

Вернёмся к аннотированию вызова.
Алгоритм аннотации аргументов вызова в точности соблюдает инвариант.
Каждое вызываемое в конкретном направлении отношение добавляется в стек, если оно там отсутствовало, и инициализируется так, что его входные переменные имеют аннотацию $0$.
Это позволяет рассматривать аннотацию тела вызываемого отношения независимо от причин аннотирования: является ли аннотируемая цель целью программы или телом вызываемого отношения.

Для случая необходимости добавления генерации остаётся заметить, что данная модификация лишь изменяют структуру программы, но не производит аннотирование.
За счёт чего можно утверждать, что инвариант сохраняется.
\end{proof}
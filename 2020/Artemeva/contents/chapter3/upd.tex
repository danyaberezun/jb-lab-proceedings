\subsection{Нормализация программ для аннотирования}
\label{sec:normalize}

Нормализация программ для аннотирования с вызовами на термах-конструкторах рассматривается в последующих разделах.
Доказательство того, что любое отношение \miniKanren{} можно преобразовать в нормальную форму приводится в подразделе~\ref{lab:normProof}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Нерекурсивные вызовы на конструкторах}
\label{lab:non-rec}

К моменту вызова аргумент-конструктор может быть проаннотирован частично.
В этом случае неизвестно является ли переменная, соответствующая данному аргументу, входной или выходной.
Другими словами, невозможно определить направление вызова.

Для решения проблемы нерекурсивных вызовов на конструкторах будем действовать следующим образом.
\begin{itemize}
    \item Сформируем новое отношение, принимающее на вход все переменные аргументов вызова. Его тело --- тело вызываемого отношения с подставленными в него аргументами.
    \item Вызов исходного отношения на аргументах-конструкторах заменим на вызов нового отношения на аргументах-переменных. 
\end{itemize}

Рассмотрим вызов $append^o~(a:as)~ys~z$.
Один из его аргументов --- конструктор списка.
Сформируем новое отношение $append^o1$ (см. рисунок ~\ref{lst:appendo1}), осуществив подстановку $x~\gets~(a:as)$ в тело $append^o$.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.35\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=62, escapechar=|]
  $append^o1$ $a$ $as$ $y$ $z$ =
    ($fresh$ [$h$, $t$, $r$] (
        a $\equiv$ h $\wedge$ |\label{line:appendo13}|
        as $\equiv$ t $\wedge$ |\label{line:appendo14}|
        z $\equiv$ h : r $\wedge$ |\label{line:appendo15}|
        $append^o$ t y r |\label{line:appendo16}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $append^o1 \ a \ as \ y \ z$, полученное подстановкой $x~\gets~(a:as)$ в $append^o \ x \ y \ z$}
  \label{lst:appendo1}
\end{figure}

Заметим, что первый дизъюнкт $append^o$ отсутствует в $append^o1$.
Он стал заведомо ошибочен: унификация $x \equiv []$ обратилась в $(a:as) \equiv []$.
Во втором дизъюнкте первый конъюнкт обратился в унификацию двух конструкторов и, как следствие, был заменен на конъюнкцию двух унификаций.

Производить замену вызова на аргументах-конструкторах нужно также в теле созданного отношения, поэтому вышеописанные шаги должны выполняться до достижения неподвижной точки.
В связи с этим можем получать зацикливание при работе с рекурсивными вызовами на конструкторах.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Рекурсивные вызовы на конструкторах}
\label{lab:rec}

Рассмотрим аннотирование рекурсивных вызовов на конструкторах на примере.
Отношение $revacc^o$ связывает три списка: третий получается переворачиванием первого, а второй является аккумулятором.
$revacc^o$ приведено на рисунке~\ref{lst:revacco}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=69, escapechar=|]
  $revacc^o$ $xs$ $acc$ $sx$ =
    ($xs$ $\equiv$ [] $\wedge$ $sx$ $\equiv$ $acc$) $\vee$ |\label{line:revacco2}|
    ($fresh$ [$h$, $t$] (
        $xs$ $\equiv$ $h$ : $t$ $\wedge$ |\label{line:revacco4}|
        $revacc^o$ $t$ $(h~\%~acc)$ $sx$ |\label{line:revacco5}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $revacc^o xs \ acc \ sx$}
  \label{lst:revacco}
\end{figure}

Данное отношение содержит рекурсивный вызов на конструкторе в строке~\ref{line:revacco5}.
Попробуем заменить его на новое отношение в соответствии с шагами, описанными в разделе~\ref{lab:non-rec}.
Подстановка $aсс~\gets~(h:acc)$ в $revacc^o$ представлена на рисунке~\ref{lst:revacco1}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.45\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=75, escapechar=|]
  $revacc^o1$ $xs$ $h$ $acc$ $sx$ =
    ($xs$ $\equiv$ [] $\wedge$ $sx$ $\equiv$ $(h~\%~acc)$) $\vee$ |\label{line:revacco12}|
    ($fresh$ [$h'$, $t$] (
        $xs$ $\equiv$ $h'$ : $t$ $\wedge$        |\label{line:revacco14}|
        $revacc^o$ $t$ $(h'~\%~(h~\%~acc))$ $sx$ |\label{line:revacco15}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $revacc^o1 \ xs \ h \ acc \ sx$, полученное подстановкой $acc~\gets~(h:acc)$ в $revacc^o \ x \ y$}
  \label{lst:revacco1}
\end{figure}

Видно, что в строке~\ref{line:revacco15} такая подстановка привела только к большей вложенности конструкторов.
Это означает, что неподвижная точка не будет достигнута никогда.

Альтернативное решение проблемы рекурсивных вызовов на конструкторах состоит из двух шагов:
\begin{itemize}
    \item в дизъюнкт, содержащий рекурсивный вызов на конструкторе, добавим конъюнкт --- унификацию этого конструктора с новой переменной;
    \item в вызове аргумент-конструктор заменим на новую переменную.
\end{itemize}

На рисунке~\ref{lst:revacco2IOOANN} приведён пример применения данного решения и результат аннотирования $revacc^o \ xs \ ? \ ?$.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.35\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=81, escapechar=|]
  $revacc^o2$ $xs0$ $acc1$ $sx1$ =
    ($xs0$ $\equiv$ [] $\wedge$
    $sx1$ $\equiv$ $<gen:>$ $\wedge$|\label{line:revacco2IOOANN2}|
    $sx1$ $\equiv$ $acc2$) $\vee$ |\label{line:revacco2IOOANN3}|
    ($fresh$ [$h$, $t$, $hacc$] (
        $xs0$ $\equiv$ $h1$ : $t1$ $\wedge$ |\label{line:revacco2IOOANN5}|
        $hacc2$ $\equiv$ $h1$ : $acc3$ $\wedge$ |\label{line:revacco2IOOANN6}|
        $revacc^o$ $t1$ $hacc2$ $sx2$ |\label{line:revacco2IOOANN7}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат аннотирования отношения $revacc^o \ xs \ ? \ ?$, полученного унификацией аргумента-конструктора с первым входным аргументом из $append^o \ x \ y \ z$}
  \label{lst:revacco2IOOANN}
\end{figure}

Унификация позволит определять к моменту вызова, является ли аргумент, бывший конструктором, входным или выходным.
Недостатком данного подхода является возможность потерять информацию об аннотациях переменных конструктора для аннотирования тела вызова.
Потеря этой информации может привести к завершению аннотирования неудачей.
Применение алгоритма аннотирования с добавлением генерации (см. рисунок~\ref{alg:addGeneration}) способно исправить ситуацию.

Данный подход может работать и для нерекурсивных вызовов на конструкторах, но он с большей вероятностью потребует генерацию, применения которой хочется избежать.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Вызовы на повторяющихся переменных}

Вызовы отношений могут происходить на одних и тех же переменных.
В этом случае аннотации соответствующих аргументов обязаны совпадать.
Это делает невалидными некоторые направления, которые, судя по количеству аргументов, должны существовать.

Рассмотрим пример: $append^o~x~x~z$.
У $append^o$ три аргумента и, значит, восемь направлений.
Однако, первые два аргумента данного вызова совпадают и направлений остаётся четыре, так как направления с разной аннотацией первых двух аргументов становятся невалидными.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.35\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=90, escapechar=|]
  $append^o2$ $x$ $z$ =
    ($x$ $\equiv$ [] $\wedge$ $x$ $\equiv$ $z$) $\vee$ |\label{line:appendo22}|
    ($fresh$ [$h$, $t$, $r$] (
        $x$ $\equiv$ $h$ : $t$ $\wedge$ |\label{line:appendo24}|
        $z$ $\equiv$ $h$ : $r$ $\wedge$ |\label{line:appendo25}|
        $append^o$ $t$ $x$ $r$          |\label{line:appendo26}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{$append^o2 \ x \ z$, полученное подстановкой $y~\gets~x$ в $append^o \ x \ y \ z$}
  \label{lst:appendo2}
\end{figure}

Справиться с проблемой вызовов на одних и тех же переменных помогает тот же подход, что и для нерекурсивных вызовах на конструкторах: создадим новое отношение, подставив аргументы в тело исходного.
В созданном отношении (см. рисунок~\ref{lst:appendo2}) заведомо не может существовать невалидных направлений.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Доказательство утверждения о нормализации}
\label{lab:normProof}

\begin{theorem}
    Любое отношение на \miniKanren{}, записанном в синтаксисе на рисунке~\ref{lst:miniKanren} можно привести к нормальной форме, представленной на рисунке~\ref{fig:normMiniKanren}.
\end{theorem}

\begin{proof}
    Необходимо показать, что любое отношение ненормализофанной формы~\ref{lst:miniKanren} можно привести к отношению нормализованной формы~\ref{fig:normMiniKanren}.
    Для доказательства воспользуемся идеей структурной индукции: разберём способы приведения каждого из конструктов к нормальной форме.
    
    \textit{Унификация}.
    Запрещены унификации двух конструкторов.
    Пусть существует унификация $C~name~[t_0 \dots t_k]~:=:~C~name~[s_0 \dots s_k]$, где $t_i$ и $s_i$ --- термы.
    Ее можно заменить на конъюнкцию унификаций вида $t_0~:=:~s_0~\wedge~\dots~\wedge~t_k~:=:~s_k$.
    Если среди пар унификаций вида $t_i~:=:~s_i$ окажется унификация двух конструкторов, ее так же необходимо заменить на конъюнкцию унификаций.
    
    \textit{Вызов отношения}.
    Запрещены вызовы отношений на аргументах-конструкторах.
    Случаи нерекурсивного и рекурсивного вызовов на аргументах-конструкторах рассмотрены в разделах~\ref{lab:non-rec} и~\ref{lab:rec} соответственно.
    В данных разделах рассказывается, как из вызовов на аргументах-конструкторах получить вызовы на переменных.
    
    \textit{Объявление новых переменных}.
    $fresh$-цель разрешена только на самом верхнем уровне.
    Если уникально переименовать все $fresh$-переменные отношения, то $fresh$-цель можно оставить только на самом верхнем уровне, избежав перекрытия имён.
    
    \textit{Конъюнкция и дизъюнкция}.
    Нормализованное отношение должно быть в ДНФ.
    Приведение булевого выражения в дизъюнктивную нормальную форму --- тривиальная задача.
\end{proof}

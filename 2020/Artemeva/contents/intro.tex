\section*{Введение}

Реляционное программирование --- парадигма, в которой любая программа является математическим отношением на аргументах. 
Имея программу-отношение, можно выполнять запросы: указывая последовательность известных аргументов, получать значения остальных.
Например, $add^o \subseteq Int \times Int \times Int$ описывает отношение, третий аргумент которого является суммой первых двух. 
Рассмотрим некоторые направления вычисления этого отношения (здесь и далее искомый аргумент будем обозначать знаком ``$?$'').
Под \emph{направлением вычисления отношения} будем понимать то, какие аргументы являются входными при данном запросе:
\begin{itemize}
    \item $add^o \ x \ y \ ?$ по заданным аргументам $x$ и $y$ вычислит их сумму;
    \item $add^o \ ? \ y \ z$ найдет такие числа, которые в сумме с $y$ дадут $z$;
    \item $add^o \ ? \ ? \ z$ найдет все такие пары чисел, сумма которых равна $z$;
    \item $add^o \ ? \ ? \ ?$ вычислит всевозможные тройки чисел таких, что сумма первых двух равна третьему.
\end{itemize}

Возможность выполнения отношения в различных направлениях --- основное преимущество реляционного программирования. 
Это своеобразный шаг к декларативности: достаточно написать одну программу для получения множества целевых функций. 

Возможность выполнения отношений в различных направлениях есть и в логическом программировании, родственном реляционному.
Оно представленно такими языками, как \prolog{}~\cite{Malpas1987prolog}, \mercury{}\footnote{Официальный сайт языка \mercury{}: \url{https://mercurylang.org/}, дата последнего посещения: 20.05.2020}~\cite{SOMOGYI199617} и \curry{}\footnote{Официальный сайт языка \curry{}: \url{http://www.curry-language.org/}, дата последнего посещения: 20.05.2020}~\footnote{\curry{} является логичско-функциональным языком.}~\cite{Hanus2016CIF}.
Однако, способ поиска в пространстве решений, используемый реляционными языками, дает им преимущество перед логическими.
Основным представителем парадигмы реляционного программирования является семейство интерпретируемых языков \miniKanren{}\footnote{Официальный сайт языка \miniKanren{}: \url{http://minikanren.org/}, дата последнего посещения: 20.05.2020}.
\miniKanren{} будет рассмотрен в качестве конкретного реляционного языка в данной работе.

Возможность выполнения программ на \miniKanren{} в различных направлениях позволяет применять его для решения множества задач.
Например, для решения задачи поиска посредством решения задачи распознавания.
Пусть есть $N$-местная функция на некотором языке программирования, проверяющая, что некоторая последовательность вершин в графе формирует путь с желаемыми свойствами.
Ее можно автоматически транслировать на \miniKanren{}, получив $N+1$-местное отношение, связывающее аргументы функции с булевым значением~\cite{lozov2019relational} (истина соответствует успешному распознаванию). 
Зафиксировав значение $N+1$-ого булевого аргумента, можно выполнять поиск.
Ценность такого подхода в его простоте: решение задачи поиска всегда труднее, чем реализация распознавателя. 
Однако, выполнение отношения в некоторых направлениях может быть крайне неэффективно. 

Для повышения скорости выполнения успешно используется специализация~\cite{lozov2019relational}.
Тем не менее, чтобы избавиться от всех накладных расходов, связанных с интерпретацией программы, необходим Джонс-оптимальный специализатор~\cite{jones1993partial}.
Он существует для \prolog{}~\cite{leuschel2004prolog}, но не существует для \miniKanren{}: вопрос разработки Джонс-оптимального специализатора для \miniKanren{} вплотную не изучался и не будет рассматриваться в этой работе.

Данная работа предлагает альтернативный улучшения производительности программы в заданном направлении --- трансляцию в функциональный язык.
Его суть --- по отношению с фиксированным направлением генерируется функция на функциональном языке.

В качестве целевого языка трансляции выбрано подмножество функционального языка \haskell{}~\footnote{Официальный сайт языка \haskell{}: \url{https://www.haskell.org/}, дата последнего посещения: 20.05.2020}.
Данный выбор обоснован такими особенностями языка \haskell{}, как ленивые вычисления и наличие сопоставления с образцом~\cite{Jones2003HHH, Hudak2007history, Lipovaca2011LYAH}.

Предлагаемый подход близок к специализации в контексте получаемого результата: и специализация, и трансляция на выходе имеют программу, выполняемую только в одном направлении с особенностями этого направления --- это является основанием полагать, что трансляция, как и специализация, может привести к приросту скорости выполнения программы.
Например, при трансляции из результирующей программы также могут удаляться части программы, заведомо неиспользующиеся при выполнения в выбранном направлении.

Однако, разработка транслятора, обеспечивающего прирост производительности, нетривиальная задача.
Как следствие, данная работа не ставит целью разработать транслятор в функциональный язык программирования, выдающий наилучший с точки зрения производительности результат.
Данная работа делает первый шаг к этому, разрабатывая прототип транслятора, а также проверяет, что транслированные программы корректны.

\subsubsection*{Сокращения}

АСД --- абстрактное синтаксическое дерево --- в информатике конечное помеченное ориентированное дерево, в котором внутренние вершины сопоставлены (помечены) с операторами языка программирования, а листья --- с соответствующими операндами.

ДНФ --- дизъюнктивная нормальная форма --- булевой логике нормальная форма, в которой булева формула имеет вид дизъюнкции конъюнкций литералов.

\subsection{Особенности \miniKanren{}}
\label{lab:features}

\miniKanren{} является реляционным языком программирования, в то время как трансляция осуществляется в функциональный.
Данный раздел рассматривает особенности \miniKanren{} и способы их поддержки в функциональном языке \haskell{}.

Все рассматриваемые в данном разделе особенности проиллюстрированы результатами трансляции отношения $append^o$ (см. рисунок~\ref{lst:appendo}) в различных направлениях.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Несколько выходных переменных}

Не всегда результатом выполнения отношения является единственный ответ.
Например, при выполнении отношения $append^o \ ? \ ? \ z$ интерпретатор \miniKanren{} вычислит \emph{все} возможные \emph{пары} списков, дающие при конкатенации~$z$.

В~общем случае отношению $R \subseteq X_0 \times \dots \times X_n$, с известными аргументами $X_{i_0}, \dots X_{i_k}$, и неизвестными $X_{j_0}, \dots X_{j_l}$, соответствует функция, возвращающая список результатов: 
\[F : X_{i_0} \to \dots \to X_{i_k} \to [X_{j_0} \times \dots \times X_{j_l}].\]

В качестве решения проблемы нескольких выходных переменных предлагается использовать кортежи.
Пример трансляции $append^o$ в обратном направлении приведён на рисунке~\ref{lst:appendoOOITR}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=97, escapechar=|]
    appendoOOI x0 = appendoOOI0 x0 ++ appendoOOI1 x0 |\label{line:appendoOOITR1}|
    appendoOOI0 s4$@$s0 = do                         |\label{line:appendoOOITR2}|
      let s3 = []                                    |\label{line:appendoOOITR3}|
      return $\$$ (s3, s0)                           |\label{line:appendoOOITR4}|
    appendoOOI0 _ = []                               |\label{line:appendoOOITR5}|
    appendoOOI1 s4$@$(s5 : s7) = do                  |\label{line:appendoOOITR6}|
      (s6, s0) <- appendoOOI s7                      |\label{line:appendoOOITR7}|
      let s3 = (s5 : s6)                             |\label{line:appendoOOITR8}|
      return $\$$ (s3, s0)                           |\label{line:appendoOOITR9}|
    appendoOOI1 _ = []                               |\label{line:appendoOOITR10}|
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции отношения $append^o \ ? \ ? \ z$}
  \label{lst:appendoOOITR}
\end{figure}

Символы $OOI$ рядом с названием функции в строке~\ref{line:appendoOOITR1} обозначают направление трансляции отношения.
Так, $O$ обозначает выходной аргмент и $I$ --- входной.
Пример получения кортежа в качестве результата находится в строке~\ref{line:appendoOOITR7}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Пересечение результатов дизъюнктов}

Дизъюнкты в программе на \miniKanren{} независимы и результатом вычисления каждого дизъюнкта является множество ответов.
При этом, результат вычисления дизъюнкции --- объединение этих множеств.

Иногда при трансляции с учетом направления оказывается, что сгенерированное по двум разным дизъюнктам сопоставление с образцом всех входных переменных совпадает. 
Например, рассмотрим дизъюнкцию $(x \equiv h:t \wedge y \equiv 1) \vee (x \equiv h:t \wedge y \equiv 2)$. 
Если входной переменной является $x$, то в результате трансляции необходимо осуществить сопоставление с образцом $h:t$ дважды, в первом случае вернув значение $1$, а во втором~--- $2$.

В соответствии с семантикой языка \haskell{}, вычисление сопоставления с образцом осуществляется сверху вниз, при этом если входное значение подходит под образец, следующие образцы рассматриваться не будут. 
Если транслировать каждый дизъюнкт в отдельную строку определения функции, некоторые результаты могут не быть вычислены ввиду их положения в программе. 

Для решения этой проблемы каждый дизъюнкт транслируется во вспомогательную функцию. 
Самому отношению будет соответствовать функция, конкатенирующая результаты вычисления этих вспомогательных функций.

Примером такого поведения и соответствующей трансляции является $append^o \ ? \ ? \ z$ (см. рисунок~\ref{lst:appendoOOITR}).
Здесь $appendoOOI$ является основной функцией, объединяющей результаты вспомогательных функций $appendoOOI0$ и $appendoOOI1$.
Стоит обратить внимание, что рекурсивно в строке~\ref{line:appendoOOITR7} вызывается функция $appendoOOI$, построенная по всему отношению, а не какие-либо вспомогательные функции.
Если запустить $appendoOOI$ на списке из трёх элементов $[1,~2,~3]$, можно получить список всех пар списков, конкатенация которых даёт входящий список: \\ $[([],~[1,~2,~3]),~([1],~[2,~3]),~([1,~2],~[3]),~([1,~2,~3],~[])]$.
Анализируя этот ответ легко понять, что первый кортеж получен из первого дизъюнкта (функции $appendoOOI0$), а все последующие --- из второго (функции $appendoOOI1$).

Стоит отметить тот факт, что результатом выполнения вспомогательных функций может быть и бесконечный список ответов.
В этом случае используется способность \haskell{} к ленивым вычислениям.
Несмотря на наличие конкатенации с другими списками, будет вычислено ровно столько ответов, сколько запросит пользователь, даже если все они будут возвращены только одной из вспомогательных функций.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Недетерминированность результатов}
\label{sec:nedeterm}

\miniKanren{} способен возвращать несколько значений одной переменной в качестве результата, моделируя недетерминированность.
Примером такого поведения является результат выполнения $append^o \ ? \ ? \ z$: ответами могут быть сразу несколько пар списков, конкатенация которых даст список $z$.

Недетерминироаванность классически моделируется при помощи такой структуры данных как список. 
Мы используем монаду списков и $do$-нотацию языка \haskell{} для большей лаконичности описания программ.

Её применение также можно видеть на примере трансляции цели $append^o \ ? \ ? \ x$, представленном на рисунке~\ref{lst:appendoOOITR}.
Связывание в строке~\ref{line:appendoOOITR7} означает, что результат будет вычислен для каждого элемента списка, полученного из рекурсивного вызова функции.
Унификации неизвестных переменных (например $x~\equiv~[]$ и $x~\equiv~(h:t)$) при трансляции преобразуются в $let$-связывания (строки~\ref{line:appendoOOITR3} и~\ref{line:appendoOOITR8}). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Переменные, принимающие все возможные значения}
\label{sec:transgen}

При вычислении отношений в различных направлениях иногда встречается ситуация, когда $fresh$-переменные, унифицирующиеся только друг с другом.
В этом случае они остаются свободными. 
С точки зрения денотационной семантики~\cite{rozplokhas2019certified} языка \miniKanren{} такие переменные могут принимать любые допустимые значения.
В зависимости от реализации, эти значения могут быть какими угодно или только значениями подходящего типа. 
Так как трансляция в этой работе осуществляется в статически типизированный язык, необходимо обеспечить некоторый генератор значений допустимого типа: например, всех натуральных чисел или всех списков, состоящих из значений заданного типа. 

Проблема переменных, принимающих все возможные значения, обсуждалась при разработке алгоритма аннотирования под названием ``Зависимость $fresh$-переменных только друг от друга'' в разделе~\ref{lab:gen}).
В результате её разрешения на этапе аннотирования в дизъюнкте создаются специальные унификации вида $x~\equiv~C~gen~[]$. 
Здесь $x$ --- переменная, остававшаяся свободной, а $C~gen~[]$ --- терм-конструктор, имя которого является зарезервированным словом и позволяет транслятору понять, что необходимо сгенерировать все допустимые значения переменной $x$.

В \miniKanren{} список допустимых значений переменной $x$ может быть бесконечным, соответственно, в некоторых случаях будет происходить генерация бесконечного числа значений.
Способность \haskell{} к ленивым вычислениям позволит успешно произвести вычисления даже с наличием переменной с бесконечным количеством значений, вернув столько ответов, сколько запросит пользователь.

Рассмотрим пример трансляции $append^o \ x \ ? \ ?$ (см. рисунок~\ref{lst:appendoIOOTR}).

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.62\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=107, escapechar=|]
appendoIOO x0 = appendoIOO0 x0 ++ appendoIOO1 x0
appendoIOO0 s0$@$[] = do
    s1 <- (gen)                                    |\label{line:appendoIOOTR3}|
    let s2 = s1                                    
    return $\$$ (s1, s2)
appendoIOO0 _ = []
appendoIOO1 s0$@$(s3 : s4) = do
  (s1, s5) <- appendoIOO s4
  let s2 = (s3 : s5)
  return $\$$ (s1, s2)
appendoIOO1 _ = []
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции отношения $append^o \ x \ ? \ ?$}
  \label{lst:appendoIOOTR}
\end{figure}

Генерация здесь происходит в строке~\ref{line:appendoIOOTR3} и представляет собой вызов функции $gen$, возвращающей список всех возможных списков.
Функция $gen$ является функцией класса типов $Generator$ (см. рисунок~\ref{lst:generator}).

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.6\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=118, escapechar=|]
class Generator a where
  gen :: [a]
        
instance (Generator a) => Generator [a] where
  gen = [] : do
    xs <- gen
    x <- gen
    return (x : xs)

instance Generator Int where
  gen = [0..9]
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Класс типов $Generator$ и его реализации для списков и цифр}
  \label{lst:generator}
\end{figure}

Генерация при трансляции устроена следующим образом.
Переменные программы на нетипизированном \miniKanren{} при трансляции в типизированный \haskell{} обретают типы.
Типы переменных для некоторых заранее зафиксированных типов могут быть выведены из унификаций с конструкторами. 
Например, в $append^o$ в строке~\ref{line:appendo4} есть унификация переменной $x$ c конструктором списка. 
Транслятор преобразует эту унификацию в сопоставление с образцом, использующее конструктор списка, а это позволяет \haskell{} вывести, что тип переменной $x$ --- список.
Для успешной компиляции порожденной программы пользователю необходимо предоставить подходящий по типу генератор значений, реализовав член класса типов $Generator$.
Иногда также пользователю необходимо указать тип переменной, если \haskell{} не справился с выводом типа для нее.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Порядок и направление при исполнении отношения в различных направлениях}

Самая главная особенность --- выбор направления вычисления отношения влияет на порядок и направление исполнения конструкций внутри этого отношения.
Так, отношение, выполненное в заданном направлении, можно рассматривать как отображение из известных аргументов в неизвестные. 
Например, отношение $append^o \ x \ y \ ?$ соответствует функции конкатенации списков $x$ и $y$.

Отношение $append^o$ состоит из двух дизъюнктов (см. рисунок~\ref{lst:appendo}). 
Первый дизъюнкт означает, что если $x$ является пустым списком, то $y$ совпадает с $z$. 
Второй дизъюнкт означает, что $x$ и $z$ являются списками, начинающимися с одного и того же элемента, при этом ``хвостом'' $z$ является результат конкатенации ``хвоста'' списка $x$ со списком $y$. 
Унификация с участием неизвестной переменной $z$ указывает на то, \emph{как} вычислить её значение, в то время как унификация известной переменной $x$ --- \emph{при каком условии}.

Трансляция $append^o \ x \ y \ ?$ создаст функцию, приведенную на рисунке~\ref{lst:appendoIIOTR}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.75\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=129, escapechar=|]
appendoIIO x0 x1 = appendoIIO0 x0 x1 ++ appendoIIO1 x0 x1

appendoIIO0 s3$@$[] s0 = do                                  |\label{line:appendoIIOTR2}|
  let s4 = s0
  return $\$$ (s4)
appendoIIO0 _ _ = []                      |\label{line:appendoIIOTR5}|

appendoIIO1 s3$@$(s5 : s6) s0 = do                           |\label{line:appendoIIOTR6}|
  (s7) <- appendoIIO s6 s0
  let s4 = (s5 : s7)
  return $\$$ (s4)
appendoIIO1 _ _ = [] |\label{line:appendoIIOTR10}|
  \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции отношения $append^o \ x \ y \ ?$}
  \label{lst:appendoIIOTR}
\end{figure}

Видно, что в результате трансляции второго дизъюнкта конъюнкты отношения поменяны местами.
Получен следующий порядок:
\begin{itemize}
    \item $let~(h:t)~=~x$
    \item $r~\gets~apppend^o~t~y$
    \item $let~x~=~(h:r)$
    \item $return~z$
\end{itemize}

Пример трансляции $append^o \ ? \ ? \ z$ приведен на рисунке~\ref{lst:appendoOOITR}.
Так же, как и для $append^o \ x \ y \ ?$, выпишем полученную после трансляции последовательность вычисления конъюнктов отношения $append^o \ ? \ ? \ z$:
\begin{itemize}
    \item $let~(h:r)~=~z$
    \item $(t,y)~\gets~apppend^o~r$
    \item $let~x~=~(h:t)$
    \item $return~(x,y)$
\end{itemize}

Таким образом, порядок вычислений в функциях не совпадает с порядком конъюнктов в исходном отношении.
Проблема изменения порядка и направления при исполнении отношения в различных направлениях была указана во введении как мотивация к разработке алгоритма аннотирования переменных.
Адаптация анализа времени связывания к \miniKanren{} и есть решение данной проблемы (см. главу~\ref{annotator}).
Рассмотрим конкретный пример, как аннотации переменных помогают выбрать порядок и направления вычислений отношений.

Пусть есть проаннотированное $append^o \ ? \ ? \ z$ (см. рисунок~\ref{lst:appendoOOIANN}), которое необходимо транслировать.
Результат трансляции есть на рисунке~\ref{lst:appendoOOITR}.

Рассмотрим первый дизъюнкт.
В начале определим направления вычислений каждого из конъюнктов.
Направление первого из них (в строка~\ref{line:appendoOOIANN2}): $let~x~=~[]$, так как аннотация константы всегда меньше аннотации невходной переменной.
Направление второго --- $let~y~=~z$, потому что аннотация $z$ является $0$ (входная переменная), в то время как $y$ --- $1$.
Таким образом, направление выбирается в соответствии с тем, какой части унификации принадлежит большая аннотация: кто содержит наибольшую, тому будет происходить присваивание.
Для определения порядка достаточно отсортировать получившиеся на прошлом шаге определения от меньшего к большему по аннотации определяемой переменной.
В примере аннотации $x$ и $y$ совпадают и равны $1$, поэтому в данном случае нам не важен их порядок.
При трансляции (см. рисунок~\ref{lst:appendoOOITR}) определение $y$ станет частью сопоставления с образцом (о том, как это работает, будет рассказано в следующем разделе) в строке~\ref{line:appendoOOITR2}, а определение $x$ --- строкой~\ref{line:appendoOOITR3}.

Перейдём ко второму дизъюнкту.
Определим направления.
Унификация в строке~\ref{line:appendoOOIANN4} транслируется в определение $let~x~=~(h~:~t)$, потому что аннотация $x$ больше обоих аннотаций переменных $h$ и $t$.
Строка~\ref{line:appendoOOIANN5} даст определение $let~(h~:~r)~=~z$.
Направление вызова функции в строке~\ref{line:appendoOOIANN6} также определим по максимальной аннотации аргументов вызова.
В данном случае она равна $2$ и встречается у двух переменных --- $t$ и $y$.
Это означает, что вызов происходит в том же направлении, что и исходное отношение, и направление будет выглядеть следующим образом: $(t,~y) \gets append^oOOI~r$.
Сортировка определений позволит получить такой порядок: $(h~:~r)$, $(t,~y)$, $x$.
При трансляции они окажутся, соответственно, в~\ref{line:appendoOOITR6},~\ref{line:appendoOOITR7}~и~\ref{line:appendoOOITR8} строках.

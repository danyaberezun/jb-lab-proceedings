\subsection{Описание трансляции}

Данный раздел приводит описание трансляции программы в абстрактном синтаксисе \miniKanren{} в программу в абстрактном синтаксисе \haskell{}.

Первым шагом трансляции является нормализация (см. раздел~\ref{sec:normalize}), после чего происходит запуск алгоритма аннотирования нормлизованной программы на \miniKanren{}~\ref{alg:annotate} с модификациями для решения проблемы нескольких вызовов в одном дизъюнкте (см. алгоритм на рисунке~\ref{alg:annotateDisjWithSomeInvokes}) и проблемы зависимости $fresh$-переменных только друг от другоа (см. алгоритм на рисунке~\ref{alg:addGeneration}).
Таким образом, из произвольной программы на \miniKanren{} будет получен стек всех вызовов этой программы, каждый вызов в котором --- нормализованное проаннотированное в определённом направлении определение на \miniKanren{}.

Далее для каждого дизъюнкта каждого определения со стека вызовов запускается сам алгоритм трансляции.
В первом приближении он состоит из следующих шагов:
\begin{itemize}
    \item формирование списков входных и выходных переменных $in$ и $out$;
    \item разбиение конъюнктов на те, которые могут стать сопоставлениями с образцом и все остальные;
    \item удаление перекрытий имён в сопоставлении с образцом путём формирования охранных выражений;
    \item определение направлений конъюнктов;
    \item определение порядка определений;
    \item удаление перекрытий имён в определениях путём формирования условий для ветвления.
\end{itemize}

Многие из этих шагов были описаны в предыдущих разделах об особоенностях \miniKanren{} (см. раздел~\ref{lab:features}) и построении абстрактного синтаксического дерева функционального языка (см. раздел~\ref{lab:ast}).
Подробнее рассмотрим только два шага: определение направлений конъюнктов и получение порядка определений.

Получение направлений конъюнктов происходит по-разному для унификаций и вызовов.
Если конъюнкт --- унификация, определим значение максимальной аннотации в каждой из её частей.
Здесь возможны три случая.
\begin{itemize}
    \item Если эти значения равны, то унификация становится условием ветвления.
    \item Если значение левой части больше, то унификация превращается в определение, где левая часть зависит от правой; в ответ сохраняем не только получившееся определение, но и максимальную аннотацию левой части --- это необходимо для получения порядка вычисления определений.
    \item Оставшийся случай симметричен.
\end{itemize}

Если конъюнкт --- вызов отношения, определим его выходные переменные.
Для этого достаточно узнать максимальную аннотацию его аргументов --- переменные обладающие таковой, стали известны после выполнения вызова и являются зависимыми.
Также, как делали для унификаций, сохраним значение максимальной аннотации.

Получим порядок определений.
Для этого отсортируем их по максимальной аннотации их зависимой части.

\subsection{Построение абстрактного синтаксического дерева функционального языка}
\label{lab:ast}

В предыдущем разделе были разобраны особенности трансляции, связанные с \miniKanren{}.
В этом разделе рассмотрены особенности, проявившиеся в процессе разработки алгоритма трансляции и повлиявшие на структуру абстрактного синтаксическое дерева функционального языка.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Сопоставление с образцом для входных переменных}

Сопоставление с образцом --- хороший способ отфильтровать заведомо ложные вычисления, используя информацию о типе конструктора аргумента.
В качестве примера рассмотрим трансляцию $append^o$ в прямом направлении (см. рисунок~\ref{lst:appendoIIOTR}).
Дизъюнкты исходного отношения $append^o$ (см. рисунок~\ref{lst:appendo}) содержат унификации первого аргумента, являющегося входным: первый дизъюнкт --- унификацию с пустым списком (строка~\ref{line:appendoOOIANN2}), второй --- с непустым (строка~\ref{line:appendoOOIANN4}).
При трансляции такие унификации превращаются в сопоставление с образцом (см. строки~\ref{line:appendoIIOTR2} и~\ref{line:appendoIIOTR6}).
Как результат --- если первый аргумент функции является пустым списком, то успешно вычислится только $appendoIIO0$.

Стоит отметить, зачем нужны строки~\ref{line:appendoIIOTR5} и~\ref{line:appendoIIOTR10}.
Они представляют собой сопоставление с образцом, которое всегда завершится успехом, однако, они не влияют на результат вычисления, так как возвращают пустой список.
$appendoIIO1$, в случае не успешного сопоставления с образцом в строке~\ref{line:appendoIIOTR6}, попытается найти уравнение, в котором сопоставление с образцом пройдёт успешно.
Если строки~\ref{line:appendoIIOTR10} не будет, то вычисление функции $appendoIIO1$ завершится ошибкой за отсутствием возможности обработать соответствующий вход.

В случае, если в отношении на \miniKanren{} одной входной переменной соответствовало несколько унификаций, для неё появляется возможность выбрать, какая из них станет сопоставлением с образцом.
Алгоритм выбирает ту из унификаций, которая обеспечит наибольшую вложенность конструкторов. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Совпадение имён в сопоставлениях с образцом}

Имена переменных, используемых в сопоставлении с образцом, могут совпадать для разных аргументов.
Например, во втором дизъюнкте $append^o$ на рисунке~\ref{lst:appendo} есть унификации переменных $x$ и $z$.
Если мы будем транслировать $append^o \ x \ ? \ z$, то получим перекрытие имён переменных.
Переменная $h$, участвующая в обеих унификациях, окажется и в обоих сопоставлениях с образцом: для первого и третьего аргументов.

На рисунке~\ref{lst:appendoIOITR} представлен результат трансляции $append^o$ в обсуждаемом направлении.
Второму дизъюнкту в нем соответствует функция $appendoIOI1$, а переменной $h$ --- переменная $s3$.
Чтобы избежать перекрытия имён, $s3$ была переименована в $p2$ в сопоставлении с образцом для второго аргумента.
Переименовывание нарушило условие, созданное при трансляции в данном направлении: оба аргумента-списка должны иметь одинаковый первый элемент списка.
Восстановление этого условия происходит за счёт применения охранного выражения, проверяющего списки на равенство $|~s3~==~s2$.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.8\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=139, escapechar=|]
    appendoIOI x0 x1 = appendoIOI0 x0 x1 ++ appendoIOI1 x0 x1
    appendoIOI0 s0$@$[] s2@s1 = return $\$$ (s1)
    appendoIOI0 _ _ = []
    appendoIOI1 s0$@$(s3 : s4) s2$@$(p2 : s5) $|$ s3 == p2 = do
      (s1) <- appendoIOI s4 s5
      return $\$$ (s1)
    appendoIOI1 _ _ = []
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции отношения $append^o \ x \ ? \ z$}
  \label{lst:appendoIOITR}
\end{figure}

Здесь же стоит заметить ещё одну особенность: рядом с каждым сопоставлением с образцом находится его ``псевдоним''.
Этот псевдоним --- исходное имя входной переменной до замены на сопоставление с образцом.
Его необходимо сохранить для случая, если внутри тела функции потребуется именно эта переменная, а не переменные из сопоставления с образцом.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Совпадение имен в определениях}

Переменные в определениях так же могут совпадать, однако, для них нельзя использовать охранные выражения.
Для решения проблемы совпадения имен в определениях будем использовать ветвление.

На рисунке~\ref{lst:appendoAssign} представлено модифицированное отношение $apppend^o$ (см. рисунок~\ref{lst:appendo}).
Оно связывает три списка таких, что первый является повтором первого элемента второго списка, а третий --- конкатенацией первого и второго списков.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.45\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=146, escapechar=|]
  $append^oAssign$ $x$ $y$ $z$ =
    ($x$ $\equiv$ [] $\wedge$                     |\label{line:appendoAssign2}|
     $y$ $\equiv$ $z$) $\vee$                     |\label{line:appendoAssign3}|
    ($fresh$ [$h$, $t$, $r$, $p$, $ps$, $c$, $cs$] (
        $x$ $\equiv$ $h$ : $t$ $\wedge$           |\label{line:appendoAssign5}|
        $z$ $\equiv$ $h$ : $r$ $\wedge$           |\label{line:appendoAssign6}|
        $z$ $\equiv$ $p$ : ($p$ : $ps$) $\wedge$ |\label{line:appendoAssign7}|
        $z$ $\equiv$ $c$ : ($c$ : $cs$) $\wedge$ |\label{line:appendoAssign8}|
        $append^oAssign$ $t$ $y$ $r$              |\label{line:appendoAssign9}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $append^oAssign$}
  \label{lst:appendoAssign}
\end{figure}

Рассмотрим результат трансляции отношения $append^oAssign \ ? \ ? \ z$, представленный на рисунке~\ref{lst:appendoAssignOOITR}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=156, escapechar=|]
 appendoAssignOOI x0 = appendoAssignOOI0 x0 ++ appendoAssignOOI1 x0
 appendoAssignOOI0 s2$@$s1 = do
   let s0 = []
   return $\$$ (s0, s1)
 appendoAssignOOI0 _ = []
 appendoAssignOOI1 s2$@$(s8 : (p2 : s9)) $|$ s8 == p2 = do
   let (s3 : s5) = s2
   let (s6 : (c4 : s7)) = s2                 |\label{line:appendoAssignOOITR8}|
   (s4, s1) <- appendoAssignOOI s5
   let s0 = (s3 : s4)
   if (s6 == c4) then return $\$$ (s0, s1) else [] |\label{line:appendoAssignOOITR11}|
 appendoAssignOOI1 _ = []
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции отношения $append^oAssign \ ? \ ? \ z$}
  \label{lst:appendoAssignOOITR}
\end{figure}

Строка~\ref{line:appendoAssignOOITR8} содержит определение, полученное при трансляции унификации $z~\equiv~c~:~(c~:~cs)$.
Переменная $c$ здесь стала переменной $s6$ и получили определение $let~(s6~:~(s6~:~s7))~=~s2$.
Как и в случае аналогичной проблемы с сопоставлением с образцом, переименуем повторившуюая переменную.
После чего необходимо добавить проверку на равенство исходной и переменной-замены.
Все такие проверки накапливаются и происходят в конце --- перед возвратом значения.
Так, в~\ref{line:appendoAssignOOITR11} строке показано, что в случае невыполнения условия необходимо вернуть пустой список.
Если условие выполняется, то возвращается результат.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Трансляция конструкторов}

Терм \miniKanren{} может быть произвольным конструктором.
В этом случае, чтобы успешно выполнить полученную после трансляции функцию, необходимо знать, как вычислять данный конструктор.
При трансляции будем считать, что пользователь сам позаботится о способе вычисления конструктора, определив соответствующий тип.
На рисунке~\ref{lst:peano} приведен один из таких пользовательских конструкторов, реализующих натуральные числа.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=168, escapechar=|]
    data Peano = O $|$ S Peano
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Тип данных $Peano$ --- определение конструкторов $O$ и $S$}
  \label{lst:peano}
\end{figure}

Тем не менее, в трансляторе поддержаны некоторые конструкторы, такие как конструкторы списков и булевы константы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Абстрактный синтаксис функционального языка}

Абстрактный синтаксис используемого подмножества \haskell{} приведён на рисунке~\ref{lst:funcast}

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.75\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=169, escapechar=|]
    data Atom = Var String
              $|$ Ctor String [Atom]
              $|$ Tuple [String]
    
    data Expr = Term Atom
              $|$ Call String [Atom]
    
    data Assign = Assign Atom Expr
    
    newtype Guard = Guard [Atom]
    
    data Pat = Pat (Maybe String) Atom
    
    data Line = Line [Pat] [Guard] [Assign] [Guard] Expr
    
    data F = F String [Line]
    
    newtype FuncProgram = FuncProgram [F]
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Абстрактный синтаксис функционального языка}
  \label{lst:funcast}
\end{figure}

Транслированная программа $FuncProgram$ представляет собой множество функций $F$.

Каждая функция $F$ определяется именем и списком вспомогательных функций $Line$.

Каждая вспомогательная функция $Line$ состоит из списка сопоставлений с образцом $Pat$ (представляющего собой список аргументов), списка охранных выражений $Guard$ для сопоставления с образцом, списка определений $Assign$, списка охранных выражений $Guard$ для определений и значения выражения.

Сопоставление с образцом $Pat$ состоит из опционального псевдонима и тела сопоставления с образцом, называемого в данном случае $Atom$.

$Atom$ является аналогом $Term$ из \miniKanren{} с небольшим расширением.
$Atom$ может быть переменной или конструктором, однако, ещё он может быть кортежем (конструктор $Tuple$).
Кореж --- список переменных без конструктора.
Используется, когда необходимо вернуть несколько переменных после вызова функции.

Охранное выражение $Guard$ --- список $Atom$, которые необходимо проверить друг с другом на равенство.

Определение $Assign$ представляет собой $Atom$ и $Expr$ --- значение выражения $Expr$ будет сопоставлено $Atom$.

Выражение $Expr$ может быть или тоже $Atom$, или вызовом функции на списке $Atom$.

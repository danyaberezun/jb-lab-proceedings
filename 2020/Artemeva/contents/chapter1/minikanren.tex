\subsection{Язык программирования \miniKanren{}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Реляционное и логическое программирование}

Реляционному программированию родственно логическое, представленное такими языками, как \prolog{}~\cite{Malpas1987prolog}, \mercury{}~\cite{SOMOGYI199617} и \curry{}~\cite{Hanus2016CIF}.
Исторически реляционная парадигма появилась раньше чем логическая~\cite{MacLennan1981IRP}, предложив идею программы как отношения.
Однако, логическая парадигма раньше предоставила конкретную реализацию идеи программы-отношения~\cite{Malpas1987prolog}.
Как следствие, сейчас, когда реляционная парадигма получила свое развитие, она использует опыт и идеи логической парадигмы.
В частности, большое влияние на развитие реляционной парадигмы оказали языки семейства \prolog{}~\cite{Nadathur1988OLP, Wielemaker2012TPL, Swift2012XSB}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Преимущества \miniKanren{}}

\miniKanren{} был выбран в качестве конкретного реляционного языка в данной работе по ряду причин.

Семейство языков \miniKanren{} дало рождение парадигме реляционного программирования~\cite{Byrd2009RPM, Friedman2005TRS, hemann2013ukanren}.
Как следствие, \miniKanren{} --- основной представитель реляционной парадигмы.

Возможность выполнения программ на \miniKanren{} в различных направлениях позволяет применять его для решения множества задач:
\begin{itemize}
    \item доказательство теорем~\cite{Near2008TAP};
    \item синтез программы на языке $X$ по интерпретатору языка $X$ и набору тестов~\cite{byrd2017unified};
    \item задачи вычислительной лингвистики~\cite{Varju2012UCL};
    \item решение задачи поиска посредством решения задачи распознавания~\cite{lozov2019relational}.
\end{itemize}

\miniKanren{} легко использовать в своих проектах: он компактен и способен встраиваться в языки общего назначения~\cite{hemann2013ukanren, Kosarev2018TER}.
Для встраивания достаточно реализовать интерпретатор языка \miniKanren{}, который весьма компактен: ядро языка, реализованное на \scheme{} занимает не более, чем 40 строк~\cite{Friedman2005TRS, hemann2013ukanren}.

Любая программа на \miniKanren{} найдет все существующие ответы: \miniKanren{} использует полный поиск для обхода пространства ответов со стратегией чередования с возвратом, называемый \emph{interleaving search}~\cite{kiselyov2005bit}.
На практике чаще применяется неполный поиск, поскольку он менее требователке к вычислительным ресурсам~\cite{Hanus2012SSF}.
Так, языки семейства \prolog{} используют поиск в глубину, являющийся неполным, --- как следствие, они могут никогда не завершить поиск~\cite{Schreye1994TLP, Nerode1998LFA}.
Незавершаемость программ на \prolog{} --- свойство стратегии поиска решения.
Для устранения потенциальной нетерминируемости используются нереляционные конструкции, такие как cut~\cite{Lin1997ASC}.
Эта особенность существенно усложняет и часто делает невозможным исполнение отношения в некоторых направлениях.
Рассматриваемое в данной работе подможество \miniKanren{} (далее просто \miniKanren{}) же является чистым\footnote{Сам \miniKanren{} содержит дополнительные конструкции, которые не являются реляционными.}: все языковые конструкции обратимы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Абстрактный синтаксис языка \miniKanren{}}

Рассмотрим конструкции \miniKanren{}, для которых производилась разработка алгоритма трансляции.
Программа на \miniKanren{} состоит из набора определений отношений и цели. 
Определение имеет имя, список аргументов и тело.
Тело отношения является \textit{целью}, которая может содержать \textit{унификацию термов} и \textit{вызовы отношений}, скомбинированные при помощи \textit{дизъюнкций} и \textit{конъюнкций}. 
\textit{Терм} представляет собой или \textit{переменную}, или \textit{конструктор} с именем и списком подтермов. 
Свободные переменные вводятся в область видимости при помощи конструкции $\underline{fresh}$. 
Абстрактный синтаксис языка \miniKanren{} приведен на рисунке~\ref{lst:miniKanren}.

\begin{figure}[h!]
    \begin{center}
    \begin{minipage}{0.5\textwidth}
    \begin{align*}
      Goal &: Goal \vee Goal \ \ \ \ \ \ \ \ \ \ \\
           &\mid Goal \wedge Goal \ \ \ \ \ \ \ \ \ \  \\
           &\mid Term \equiv Term \ \ \ \ \ \ \  \\
           &\mid \underline{call} \ Name \ [Term] \ \ \\
           &\mid \underline{fresh} \ [Var] \ Goal \ \ \\
      Term &: Var \\ 
           &\mid \underline{cons} \ Name \ [Term]
    \end{align*}
    \end{minipage}
    \end{center}
  \caption{Абстрактный синтаксис языка \miniKanren{}}
  \label{lst:miniKanren}
\end{figure}

Пример программы на языке \miniKanren{}, связывающей три списка, где третий является конкатенацией первых двух, приведен на рисунке~\ref{lst:appendo}. 
Для краткости $[]$ заменяет пустой список ($\underline{cons} \ Nil \ []$); $h : t$ обозначает список с головой $h$ и хвостом $t$ ($\underline{cons} \ Cons \ [h, t]$), а $[x_0, x_1, \dots, x_n]$ --- список с элементами $x_0, x_1, \dots, x_n$. 
Вызов отношения $\underline{call} \ relation \ [t_0, \dots t_k]$ записывается как $relation \ t_0 \dots \ t_k$.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.32\textwidth}
    \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $append^o$ $x$ $y$ $z$ =
    ($x$ $\equiv$ [] $\wedge$ $y$ $\equiv$ $z$) $\vee$ |\label{line:appendo2}|
    ($fresh$ [$h$, $t$, $r$] (
      $x$ $\equiv$ $h$ : $t$ $\wedge$ |\label{line:appendo4}|
      $z$ $\equiv$ $h$ : $r$ $\wedge$ |\label{line:appendo5}|
      $append^o$ $t$ $y$ $r$          |\label{line:appendo6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример программы на \miniKanren{}: $append^o$}
  \label{lst:appendo}
\end{figure}

Исполнение этого отношения на первых двух заданных списках \\ $append^o \ [1,2] \ [3] \ ?$ вернёт их конкатенацию $[1,2,3]$.
Если оставить первые два аргумента неизвестными, получим все возможные разбиения данного списка на два: результатом $append^o \ ? \ ? \ [1,2,3]$ является множество пар $\{([],[1,2,3]), ([1], [2,3]), ([1,2], [3]), ([1,2,3], [])\}$.

\subsection{Анализ времени связывания}

Особенностью реляционного программирования является возможность вычисления отношения в различных направлениях, при этом для каждого направления последовательность вычисления конструкций отношения может быть своя.
Это затрудняет трансляцию в функциональные языки программирования.
Для успешной трансляции необходимо определить направления унификаций\footnote{Унификация может не иметь направления, если к моменту вычисления обе её части известны --- в этом случае она становится условием равенства левой и правой части.} и вызовов отношений, а также их порядок исполнения с учётом направления трансляции.
Для решения такой задачи используется \textit{анализ времени связывания} (binding-time analysis). 

Анализ времени связывания разделяет программные конструкции на домены согласно моментам, когда конкретная конструкция получила связывание.
В зависимости от цели применения могут выбираться разные домены времен связывания.

В данной работе цель анализа времени связывания --- указать порядок, в котором имена связываются со значениями в процессе выполнения программы --- то есть подразумевается динамическое связывание.

\subsubsection{Аналоги анализа времени связывания для \miniKanren{}}

Анализ времени связывания используется при offline-специализации программ~\cite{jones1993partial}. 
В этом случае он используется для определения того, какие данные известны статически и должны быть учтены при специализации, а какие неизвестны. 
Также часто определяется, какие функции вообще следует специализировать и каким образом. 

Есть анализ времени связывания для функционально-логического языка \mercury{}~\cite{vanhoof2004binding} и логического языка \prolog{}~\cite{leuschel2004prolog} --- представителей родственных реляционному программированию парадигм.
Однако в языке \mercury{} анализ времени связывания~\cite{vanhoof2004binding} используется для эффективной компиляции. 
При этом используются только аннотации in и out --- статические и динамические переменные. 
Этого недостаточно, чтобы определить порядок вычислений при трансляции в функциональный язык.
Определение порядка вычислений в \mercury{} осуществляется во время более трудоемкого анализа модов (mode analysis), использующего типы.
Соответственно, непосредственное использование этого подхода для \miniKanren{} невозможно, так как не все языки семейства типизируемы, а анализ времени связывания \mercury{} осуществляется с учётом графа типов, построенного по программе. 

Система \logen{} реализует анализ времени связывания для чистого подмножества \prolog{}~\cite{leuschel2004prolog}.
Основное предназначение анализа в этой работе --- улучшение качества специализации.
Как следствие, используется недостаточное количество типов аннотаций для того, чтобы произвести упорядочивание вызовов.

Анализ времени связывания для лямбда-исчисления с функциями высшего порядка описывается в статье~\cite{Thiemann1997AUF}.
Его цель --- определить порядок связывания переменных, --- поэтому в качестве аннотаций предлагается использовать отрезок натурального ряда $\{ 0, 1, \dots, N \}$.
Эта идея была использована в данной работе.

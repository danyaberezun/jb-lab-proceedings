\subsection{Трансляция в функциональный язык}

Как было сказано во введении, разработка транслятора, обеспечивающего прирост производительности, нетривиальная задача, поэтому данная работа не ставит целью разработать транслятор в функциональный язык программирования, выдающий наилучший с точки зрения производительности результат.

Рассмотрим причины осложнения задачи трансляции.

Последовательность конструкций в тексте программы на \miniKanren{} способна влиять на направления вычислений этих конструкций (пример данной проблемы приводится в разделе~\ref{lab:sortProblem} в главе~\ref{test}).
При трансляции определённое сочетание направлений вычислений нескольких конструкций может привести к существенному замедлению работы транслированной программы при том, что сочетание других направлений позволило бы получить ускорение.
Конкретный пример данной проблемы приведён в разделе~\ref{lab:sortProblem} главы~\ref{test}.
Проблема влияния последовательности конструкций на скорость выполнения транслированной программы требует реализовать алгоритм поиска такого порядка конструкций, при котором скорость выполнения транслированной программы была бы максимальной.
Разработка данного алгоритма является темой отдельного исследования.

Другая причина --- последовательность выдачи ответов транслированной программой.
При вычислении отношения на \miniKanren{} в конкретном направлении будет получена определенная последовательность ответов.
Вопрос: насколько важно сохранять порядок выдачи ответов транслированной в соответствущем направлении программой на языке \haskell{}?
Способу сохранить порядок посвящена большая часть статьи о трансляции логическо-функциональных программ в чистые функциональные программы~\cite{Brassel2008FFL}.
Нужно ли это делать для трансляции реляционных программ в функциональные, а также как это сделать наилучшим образом с учетом особенностей реляционного программирования, подлежит обсуждению.

\subsubsection{Аналоги трансляции реляционной программы в функциональную}

Во время трансляции по отношению на \miniKanren{} и фиксированному направлению генерируется функция на языке программирования \haskell{}.
На момент начала работы не существовало работ по трансляции реляционного языка в функциональный --- аналоги можно найти для родственной реляционному программированию парадигмы --- для логического программирования.
Однако, их невозможно применять непосредственно для трансляции реляционных программ.

Тацуру Мацусита и Колин Рансимен рассмотрели соответствия и различия \prolog{} и \haskell{}~\cite{Matsushita1997FCO}.
Одним из соответствий, которое можно использовать при трансляции реляционных программ, указывается недетерминированность результата --- в функциональной программе предлагается возвращать список результатов.
Другие соответствия, перечисленных в работе, не релевантны для \miniKanren{} по причине отсутствия (например, нет частичного применения).
В качестве различий указываются операция $cut$ и полимодальность вычислений.
Однако, в \miniKanren{} нет $cut$ и при трансляции исчезает проблема полимодальности: при трансляции отношения будет выбрано конкретное направление.

Способы расширить функциональную парадигму особенностями логической рассматриваются в статье~\cite{Bellia1986TRB}.
Так, предлагается способ добавить унификацию.
По сути, это представляет собой попытку реализовать полимодальность в функциональной программе, но при трансляции этого делать не требуется.

Поиск функциональной составляющей в логической парадигме происходит в статье~\cite{Marchiori1995the}.
Данная статья содержит главную идею трансляции: из отношения можно получить функцию, если выбрать направление вычисления.
Также в статье предлагается объединять результаты различных дизъюнктов в один список для получения одного результата из множества.
Однако, работа не предлагает конкретного алгоритма трансляции логической программы в функциональную.

Существует трансляция логического языка \mercury{}~\cite{SOMOGYI199617}, однако, данная работа предлагает трансляцию в язык программирования С, который не является функциональным.
Кроме того, основной частью алгоритма трансляции является анализ модов (mode analysis), основанный на типах.
\miniKanren{} не является типизированным, поэтому данная идея оказывается не применима при разработке транслятора для \miniKanren{}.
Вообще говоря, есть статически-типизируемые реализации \miniKanren{}, однако, мы хотим сделать общеприменимую поделку, работающую с нетипизированным ядром.

Рекомендации по трансляции логическо-функциональных программ в чистые функциональные программы приведены в статье~\cite{Brassel2008FFL}.
Работа акцентирует внимание на взаимодействии ленивости вычислений функциональных программ и недетерминированности вычислений логических программ.
Данная тема актуальна и для трансляции реляционного языка в функциональный: так, например, \miniKanren{} также присуща недетерминированность вычислений, а \haskell{} обладает свойством ленивости вычислений.
Однако, текущая разрабатываемая версия транслятора не заостряет внимание на данном моменте.
В качестве результата трансляции ожидается получение программы на \haskell{}, которая бы перечисляла те же ответы, что и программа на \miniKanren{} в транслируемом направлении, но порядок этого перечисления может не совпадать с соответсвующим порядком программой на \miniKanren{}.

Трансляция логическо-функционального языка \curry{} в функциональный язык \haskell{} предлагается в статье~\cite{Bernd2011FCL}.
Ее идеи неприменимы для трансляции из реляционного языка в функциональный в связи с особенностями логическо-функциональной парадигмы.
Так, унификация в \curry{} заменена на проверку выполняемости условий и введения ограничений на переменные ($equality \ and \ constraints$)~\cite{Hanus2016CIF}.
Однако, данная идея впоследствии использована при трансляции реляционного языка \miniKanren{} в функциональный язык \haskell{}.
